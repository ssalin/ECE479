#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include "opencv2/video/background_segm.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <math.h>

using namespace std;
using namespace cv;

int camera_number = 0;
int object_found = 0;

//threshold values
int thresh = 10;
int max_thresh = 255;
int blurctr = 0; //blur iterations
int maxblur = 15; //max blur iterations
int d_ctr = 0; //dialte iterations
int max_d_ctr = 15; //max dilate iterations
int e_ctr = 0; //erode iterations
int max_e_ctr = 15; //max erode iterations
int loopctr = 0;
int maxloop = 15;


// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> bg_model = createBackgroundSubtractorMOG2().dynamicCast<BackgroundSubtractor>();

void my_trackbars(int, void*) {// called when trackbars are instantiated
}

void createTrackbars() {
	//create window for trackbars
	namedWindow("trackbars red", WINDOW_NORMAL);
	resizeWindow("trackbars red", 300, 300);
	//create memory to store trackbar name on window
	char TrackbarNamered[50];
	createTrackbar(" Threshold:", "trackbars red", &thresh, max_thresh, my_trackbars);
	createTrackbar(" Dilate Size: ", "trackbars red", &d_ctr, max_d_ctr, my_trackbars);
	createTrackbar(" BER loop: ", "trackbars red", &loopctr, maxloop, my_trackbars);
	createTrackbar(" Blur Size: ", "trackbars red", &blurctr, maxblur, my_trackbars);
	createTrackbar(" Erode Size: ", "trackbars red", &e_ctr, max_e_ctr, my_trackbars);

}

void track_obstacle(int &x, int &y, Mat srcgray, Mat &cameraFeed) {
	Mat threshold_output;
	//threshold.copyTo(threshold_output);
	threshold(srcgray, threshold_output, 0, 255, THRESH_BINARY);
	//these two vectors needed for output of findContours
	vector< vector<Point> > contours;
	vector<Vec4i> hierarchy;
	//find contours of filtered image using openCV findContours function
	findContours(threshold_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0)); //

	// Approximate contours to polygons + get bounding rects and circles
	vector<vector<Point> > contours_poly(contours.size());
	vector<Rect> boundRect(contours.size());
	vector<Point2f>center(contours.size());
	vector<float>radius(contours.size());
	int i;
	double refArea = 0;
	bool objectFound = false;
	if (hierarchy.size() > 0) {
		int numObjects = hierarchy.size();  //if this is big, we have a noisy image
		for (int index = 0; index >= 0; index = hierarchy[index][0]) {
			Moments moment = moments((cv::Mat)contours[index]);
			for (i = 0; i < contours.size(); i++) {
				approxPolyDP(Mat(contours[i]), contours_poly[i], 3, true);
				boundRect[i] = boundingRect(Mat(contours_poly[i]));
				minEnclosingCircle((Mat)contours_poly[i], center[i], radius[i]);
			}
				objectFound = true;
				//refArea = area;
		}
		//let user know you found an object
		if (objectFound == true) {
			for (i = 0; i < contours.size(); i++) {
				Moments moment = moments((cv::Mat)contours[i]);
				//if (moment.m00 > 1000) {
					x = moment.m10 / moment.m00; //this is where the proram finds the x/y coordinates of the middle of the object
					y = moment.m01 / moment.m00; //this is where the proram finds the x/y coordinates of the middle of the 
				//	printf("%d  %d\n", x, y);
					//send XY coordinates to UDP-LAND
					drawContours(cameraFeed, contours_poly, i, 2, 1, 8, vector<Vec4i>(), 0, Point());
					rectangle(cameraFeed, boundRect[i].tl(), boundRect[i].br(), Scalar(0, 255, 0), 2, 8, 0); //tl == top left, br == bottom right
					circle(cameraFeed, center[i], (int)radius[i], Scalar(255, 0, 0), 2, 8, 0);
				//}
			}
			putText(cameraFeed, "HUMAN DETECTED", Point(0, 50), 2, 1, Scalar(0, 255, 0), 2);
			circle(cameraFeed, Point(x, y), 10, Scalar(255, 0, 0), 2);
		}
	}
}

int main()
{
	Mat cameraFeed;
	Mat HSV;
	Mat grayFeed;
	Mat img, foregroundMask, backgroundImage, foregroundImg;
	//x and y values for the location of the object

	int color = 0;
	createTrackbars();
	VideoCapture capture;
	capture.open(camera_number);


	int first_loop = 0;  //if the first loop, position the windows, don't do it over and over or I will not be able to drag windows around
	while (1) {
		int rx = 0, ry = 0; //red x and y
		int gx = 0, gy = 0; //green x and y
		int bx = 0, by = 0; //blue x and y
		int px = 0, py = 0; //pink x and y
		capture.read(cameraFeed);
		//	resize(cameraFeed, cameraFeed, Size(400, 300));
					//convert image to gray
			//cvtColor(cameraFeed, grayFeed, CV_BGR2GRAY);
			//convert frame from BGR to HSV colorspace
			//cvtColor(cameraFeed, HSV, COLOR_BGR2HSV);
			//filter and store in threshold matrix

			//		inRange(HSV, Scalar(H_MIN_green, S_MIN_green, V_MIN_green), Scalar(H_MAX_green, S_MAX_green, V_MAX_green), green_threshold);
			//erode and dilate to clean up the image
		Mat erodeElement = getStructuringElement(MORPH_RECT, Size(3, 3));
		Mat dilateElement = getStructuringElement(MORPH_RECT, Size(8, 8));

		capture.retrieve(img, CV_CAP_OPENNI_BGR_IMAGE);
		resize(img, img, Size(640, 480));

		if (foregroundMask.empty()) {
			foregroundMask.create(img.size(), img.type());
		}
		bg_model->apply(img, foregroundMask, true ? -1 : 0);
		GaussianBlur(foregroundMask, foregroundMask, Size(11, 11), 3.5, 3.5);
		threshold(foregroundMask, foregroundMask, thresh, 255, THRESH_BINARY);
		foregroundImg = Scalar::all(0);
		
		for (int i = 0; i < e_ctr; ++i) {
			dilate(foregroundMask, foregroundMask, dilateElement);
		}

		for (int i = 0; i < loopctr; ++i) {
			GaussianBlur(foregroundMask, foregroundMask, Size(11, 11), 3.5, 3.5);
			erode(foregroundMask, foregroundMask, erodeElement);
			dilate(foregroundMask, foregroundMask, dilateElement);
		}

		for (int i = 0; i < blurctr; ++i) {
			GaussianBlur(foregroundMask, foregroundMask, Size(11, 11), 3.5, 3.5);
		}
		for (int i = 0; i < d_ctr; ++i) {
			erode(foregroundMask, foregroundMask, erodeElement);
		}
	

		img.copyTo(foregroundImg, foregroundMask);
		bg_model->getBackgroundImage(backgroundImage);
		imshow("foreground mask", foregroundMask);
		imshow("foreground image", foregroundImg);

		//capture.read(frame);
		//pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
		//pMOG2->apply(cameraFeed, fgMaskMOG2);


		//erode and dilate to clean up the image
		//Mat erodeElement_red = getStructuringElement(MORPH_RECT, Size(3, 3));
		//Mat dilateElement_red = getStructuringElement(MORPH_RECT, Size(8, 8));

		//track the object
		track_obstacle(rx, ry, foregroundMask, cameraFeed);

		//get distance beween points
//		float a, b, dist_gp;
//		a = gx - px;
//		b = gy - py;
//		dist_gp = sqrt((a*a) + (b*b));

//		float c, d, dist_gr;
//		c = gx - rx;
//		d = gy - ry;
//		dist_gr = sqrt((c*c) + (d*d));

		//get angle between points
//		float angle_gp = 0;

//		if (a == 0 && b != 0) { // on x-axis
//			angle_gp = (b < 0) ? 180 : 0;
//		}
//		else if (a != 0 && b == 0) { // on y-axis
//			angle_gp = (a < 0) ? -90 : 90;
//		}
//		else { // normal move
//			if (b > 0) { // correction factor to scale with OpenCV headings
//				angle_gp = 0;
//			}
//			else {
//				angle_gp = (a > 0) ? 180 : -180;
//			}
			//printf("b = %f\n", b);
//			angle_gp += (atan(a / b) * 180.0) / 3.141592654;
//			angle_gp -= (angle_gp > 180) ? 360 : 0;
//			angle_gp += (angle_gp < -180) ? 360 : 0;
//		}
		/*
		if (b != 0)
		angle_gp = atan(a / b);
		angle_gp = (angle_gp * 180) / 3.141592654;
		*/

//		float angle_gr = 0;
//		if (d != 0)
//			angle_gr = atan(c / d);
//		angle_gr = (angle_gr * 180) / 3.141592654;
//
		//cout << "\n The hypotenuse length is: " << a << " " << b << " " << (result);
//		printf("GRN:(%d,%d)\tPNK:(%d,%d)\tRED:(%d,%d)\tBLU:(%d,%d)\tG-P:(%d,%d)\tAngGP:%.1f%c\tDstGP:%.1f\tG-P:(%d,%d)\tAngGR:%.1f%c\tDstGR:%.1f\n", gx, gy, px, py, rx, ry, bx, by, gx - px, gy - py, angle_gp, 248, dist_gp, rx - bx, ry - by, angle_gr, 248, dist_gr); //subtrace pink coordinates from pink, print the delta
																																																																		  //open all windows
		imshow("camera_feed", cameraFeed);
//		imshow("red_threshold", grayFeed);
		if (first_loop == 0) {
			first_loop = 1;
			moveWindow("camera_feed", 600, 330);
			moveWindow("red_threshold", 860, 0);
			resizeWindow("trackbars red", 300, 200);
		}
		waitKey(40);
	}
}
